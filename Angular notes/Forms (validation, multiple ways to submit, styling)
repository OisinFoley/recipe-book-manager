- Can access the entire form templating like so
<form (ngSubmit)="onSubmit(f)" #f>

- although the above is a lesser used approach.

- can also access like:
<form (ngSubmit)="onSubmit(f)" #f="ngForm">

- or in your component, define:
@ViewChild('f', { static: true }) signupForm: NgForm;
and templating of: <form (ngSubmit)="onSubmit(f)" #f="ngForm">
then 
onSubmit() { console.log(this.signupForm); }

- disabling a button can be done like so (remember #f from above):
<button [disabled]="!f.valid" type="submit">Submit</button>

- the HTML in your browser is updated with directive attrs every time you interact with an element, some of the ones for an input include

ng-invalid (when element is marked with 'required' then fails validation), and also ng-touched so you can see if element has been interacted with since initial render
-> combine these in a stylesheet for error bordering:

input.ng-invalid.ng-touched {
  border: 1px red solid;
}

-------------------------------

you can give an id to one element
<input
      type="email"
      ngModel
      required
      #email="ngModel">
then reference it in another like so:
<span *ngIf="!email.valid && email.touched">Pleaseenter a valid email</span>

--------------------------------
a quick note on ngModel vs [ngModel] with forms

in a template-driven form (which all of the above notes are for), the ngModel (w/o brackets) directive is all that is needed to tell the form that this element should be submitted with the form (maybe for some reason, you would want something inside of the form to not be submitted, well ngModel gives you that flexibility.

just remember though, that [ngModel] and [(ngModel)] can be used in a form for 1 and 2-way data binding

