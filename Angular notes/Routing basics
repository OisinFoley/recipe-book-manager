import routes and routermodule from angular core in your app module 

define a prop of type Routes which acts as an array that contains objects that have a path and correspoinding component

in your module's @NgModule decorator, loop over the routes you defined using .forRoot(appRoutes)

then, in your module's template, define a <router-outlet> element in order to conditionally render a component

e.g. - 

// module file
import { Routes, RouterModule } from '@angular/router';

const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'servers', component: ServerComponent },
  { path: 'users', component: UserComponent }
]

@NgModule({
...
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot(appRoutes)
  ],
...
})

// template
<div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
	<router-outlet></router-outlet>
</div>

to move between routes via clicks, define an attrs on an anchor like so:
	<a routerLink="/servers">Servers</a>


--------------------------------------------------------

defining relative and absolute paths:
/routeName will be absolute (i.e. - localhost/routeName)
whereas all other variations will be relative -> routeName, ./routeName, ../routeName
when doing double-dot, it's important to note that it is up one level as it was defined in the app, not just up one level in terms of number of slashes in the route string

so an app structure of:
	app/1stCompChild1stCompRoute
	app/1stCompChild1stCompRoute/1stCompChild2ndNestedCompRoute/1stCompChild3rdNestedCompRoute
will both move up to the /app route if you put a routerLink in to '../' within their templating

--------------------------------------------------------

conditionally add class to element depending on the active route:
add this attr to an element: routerLinkActive="active"
this can cause a bug on your '/' element, as routerLinkActive will be true if part of the
specified route is present in the overall path.
i.e. - in path '/somePath/someOtherPath', both the '/' element and the 'somePath/someOtherPath'
element would have their active class set - this could lead to some strange highlighting in a navbar

the way around this is to set an additional attr on the root path element in your templating, like so:
[routerLinkActiveOptions]="{ exact: true }">

full example:
<li role="presentation"
    routerLinkActive="active"
    [routerLinkActiveOptions]="{ exact: true }"> // this is the additional attr
  <a routerLink="/">Home</a>
</li>
<li role="presentation"
    routerLinkActive="active">
  <a routerLink="/servers">Servers</a>
</li>

--------------------------------------------------------

routing done programatically rather than directly through templating:
(contains a gotcha)

in your component, declare a prop of type Router, and call this.router.navigate(['/someRoute'])
unlike in templating, the default behaviour of the component in the programmatic approach is to not be aware of the current path, so any path defined in this.router.naviigate will be absolute.
to get around this and access the earlier part of the path (i.e. - /home/employees/), we declare another prop in our ctor of type 'ActivatedRoute' (e.g. - 'route') and then define an additional prop when calling .navigate(..., { relativeTo: this.route })

full example:

constructor(
    private router: Router,
    private route: ActivatedRoute) { } //additional prop

  reloadRoute() {
    this.router.navigate(['servers'], { relativeTo: this.route }); // additional arg
  }

if the route we were already on is '/servers', then this would result in trying to navigate to 
'/servers/servers'


--------------------------------------------------------

grabbing route params inside of a component:

- in your app module, define a prop like in nodeJs -> 'users/:id/:name'
- then in your component, use the prop of type ActivatedRoute (alias of route for this example) and grab its 
	this.route.snapshot.params['name']

there's a gotcha here, in that this is approach only works well if you will navigate to this component from another component.
if you navigate from this route to this same route but with different params, then they will not be available to you, meaning your url path would update, but the data available in your view would not.

if your component will have functionality that allows it it recall itself with different route params, then you must do the following in ngOnInit:

instead of:

this.user = {
        id: this.route.snapshot.params['id'],
	name: this.route.snapshot.params['name']
};

do:

// side note, route.params is an observable, hence why component is informed of updated data
// 2nd side note, because we set up the subscription here, it is not called on the initial load of the route. 
this means that we need the snippet above to initialise the data, as well as the below snippet to respond to updated route params
this.route.params
      .subscribe(
        (params: Params) => {
          this.user.id = params['id'],
          this.user.name = params['name']
        }
)
3rd side note: this is an observable that angular cleans up for you when you leave the route, due to this being an observable that is built into @angular/router.
however, with regular observables, you need to clean up and unsubscribe in the ondestroy hook whenever the component will be removed

--------------------------------------------------------
adding queryparams, or a fragment (#aboutme section of page etc.)

in templating:

[routerLink]="['/servers', 5, 'edit']"
[queryParams]="{ allowEdit: '1' }"
fragment="loading"

programmatically:
this.router.navigate(['/servers', id, 'edit'],
      {
        queryParams: { allowEdit: '1' },
        fragment: 'loading'
      }
);

and to access those params in the route that has been navigated to:

// note: the plus prepended to the next line means parseInt(the id you get back from this.route)
const id = +this.route.snapshot.params['id'];
this.route.params
      .subscribe(
        (params: Params) => {
          console.log(this.serversService.getServer(+params['id']));
        }
);

