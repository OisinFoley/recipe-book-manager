In a react app, you could handle things like accessing local storage in your reducer.
And you would make http requests in your action dispatcher files.

In NgRx, an optional feature to use is something called features.
It's optional, but is another built-in piece of NgRx functionality to help you abstract away these processes.

Installed w/: npm i --save @ngrx/effects

-----------------------
Note: Effects always execute AFTER the reducer
-----------------------
In any sort of effects class, you need to add an @Effect() decorator to your functions, so that Angular can pick up on this.

Effects, by default, should dispatch a new action.
If you don't want this behaviour, define your decorator as:
	@Effect({dispatch: false })
-----------------------
Effects need to be declared in your app.module file, like so:
imports: [
    ...
    StoreModule.forRoot(fromApp.appReducer),
    EffectsModule.forRoot([AuthEffects]),
    AppRoutingModule,
    SharedModule,
    CoreModule
  ],

Effects will never modify state, they will just:
- take an action named as a sort of preliminary action to the main action
- then it will dispatch the main action identifier, and the main identifier is dispatched to the reducer which of course, is where new state is created

Example:
// switchMap takes an observable and lets you return a new observable
// of() is an rxjs property that lets you emit an observable - in this case, we're emitting whatever we choose to return in the catchError block by using 'of()'
// rxjs' map() returns an observable, so we don't need to use 'of()' there, otherwise we're have a double observable
// an effect takes in an action and forwards on a new action, here we use of() to do so.

@Effect()
  authLogin = this.actions$.pipe(
    ofType(AuthActions.LOGIN_START),
    switchMap((authData: AuthActions.LoginStart) => {
      return this.http
        .post<AuthResponse>(
        'https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=AIzaSyA-_x0ng8JNhQzLtg-r88jM3j7OOjo3q8M',
        {
          email: authData.payload.email,
          password: authData.payload.password,
          returnSecureToken: true
        }
      ).pipe(
        map(resData => {
          const tokenExpirationDate = new Date(
            new Date().getTime() + +resData.expiresIn * 1000
          );
          return new AuthActions.Login({
            email: resData.email,
            userId: resData.idToken,
            token: resData.idToken,
            tokenExpirationDate
          });
        }),
        catchError (error => {
          return of(... here we could dispatch to an eror reducer);
        })
      );
    })
  );

