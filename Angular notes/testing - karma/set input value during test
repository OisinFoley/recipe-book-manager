Just grab the DebugElement and call:

emailInput.nativeElement.value = 'whatever you want';

Note: if you're updating an input within a form, remember that you
1) you may need to wrap the input update inside of a fixture.whenStable.then()...callback (have not needed to do this myself during my tests, regardless of type of form) and also
2) you need to access the form and 'set value' on the form (how to do so depends on if you're using template-driven or reactive forms:

It's worth noting with template-driven forms, sometimes you need to set the @Viewchild member as "static: true" (ShoppingEditComponent in recipe-book), and sometimes you need to set "static: false" (AuthComponent in recipe-book).
I haven't investigated this yet, but it would be worth knowing why.
Wasn't able to get tests to pass in either spec file when I changed their respective 'static' setting.

Examples:
- Reactive form:
(spec)
	async() 'it' block
	fixture.detectChanges();
	component.recipeForm.controls['name'].setValue('test');
	// call fixture.detectChanges(); on next line
(component)
	recipeForm: FormGroup;
	this.recipeForm = new FormGroup({
           'name': new FormControl(recipeName, Validators.required),
	});

- Template-driven form:
(spec)
	fakeAsync() 'it' block
	tick();
        fixture.detectChanges();
	// setValue takes entire form payload, hence multiple key:value
	// pairs
	component.authForm.setValue(validAuthFormValues);
        tick();
        fixture.detectChanges();
(component)
@ViewChild('f', { static: false }) authForm: NgForm;
(template)
	<form #f="ngForm" (ngSubmit)="onSubmit(f)">
	.....
	</form>


(if you don't call 'set value' for the type of form control you're using, then the UI itself will update, but the form will not pass validation (put a form.isvalid check in the function that the submit button calls and you will see))
