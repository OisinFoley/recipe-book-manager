If the prop to override is initialised in the ctor, and the value you want to use isn't crucial for initialising other props, then do the following:

TestBed.createComponent(RecipeDetailComponent);
      const component: RecipeDetailComponent = fixture.componentInstance;
      component.recipe.ingredients = [];
      expect(component.isDisabled(component.recipe)).toBe(true);

^ As time has gone on, the above has proven to be an unreliable approach.
The reason for this is that setting component.recipe.ingredients = ingrdientsList; at the end of the test doesn't actuallt reset them.
The tests run in random order by default (and a series of tests shouldn't rely on the order they run in anyway), but any test that runs after the test where we set the ingredients to an empty list will still have an empty list, hence those tests fail.

Have also tried calling
component.recipe.ingredients = ingrdientsList in an afterEach block, but that didn't work either.
Have also tried setting component.recipe = recipes[index] instead, just in case the issue was down to shallow changes not being detected, but it didn't work either.

Have instead decided to just create a dedicated describe block which is isolated from the other tests which rely on the recipe having ingredients in its list.

// This next line is an untested assumption
You could also use that approach if the prop to override is crucial to intialising other prop values, as long as you update the prop before calling .detectChanges() (remember that that will triger ngOnInit())
// end of assumption
