if we inject a service into a component, then all children of that component will also have the instance.
but, we have no way of passing the instance to a parent, so ensure to instantiate the service at the correct level in the tree

an impractical but illustrative example of where you would see the effect of injecting a service at the incorrect level is if you had a parent component which called a service (and that service just simply returns a list of objects) and then pass an object to the child.
then, within your child, you erroneously declare the NamedService as a provider (as all child components will inherit the same service instance as its parent, you just need to declare the service in your child's ctor)
because you declare the service as a provider in your child, your child actually gets a different instance of the service than your parent.
as an extension, let's say your service has a func to update a property of an object.
if you have a separate instance of the service in your child, then you will be updating a different instance of the object than that which exists in the parent.

this means that if your parent passed in an object from the service to the child,
and your child displayed these attrs in the view, then you would have a bug.
the bug would be that if the parent passed in name: oisin, and your child's instance of the service calls the updateName function, then your child would update the name only within its own instance (but the child component is displaying the name is received from the parent's instance of the service)

thereofore, the view won't update because the parent's instance of the data hasn't changed, and your child is using the data it received from the parent
the key to avoiding this bug, is to not include th service name as a provider inside your child's @Component decorator
