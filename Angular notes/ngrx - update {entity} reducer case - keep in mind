state has to be immutable, so if you want to change something small with state, such as updating an ingredient name in an array of ingredients, follwo the following pattern:

case ShoppingListActions.UPDATE_INGREDIENT:
        // const ingredient = state.ingredients[action.payload.index];
        const updatedIngredient = {
          ...action.payload.ingredient
        };
        const updatedIngredients = [...state.ingredients];
        updatedIngredient[action.payload.index] = updatedIngredient;
        return {
          ...state,
          ingredients: updatedIngredients
        };

if you're going to update a value, use the spread operator (Object.assign under the hood) to ensure that you're making a new copy of the data (i.e. - new state)

in the above example, we would include the 'updatedIngredient' constant as the first props of 'updatedIngredient' if our ingredients had unique ID properties which we wanted to maintain.
as it stood in the above example, the ingredients didn't have unique ID properties, so we just spread the contents of ...action.payload.ingredient into the "updatedIngredient" constant (essentially, we just replaced the string value of the ingredient).


we see the same concept applied to the "updatedIngredientS" constant.
- spread the current state into the new prop
- update the value at the index specified in the payload
- apply new state in the reducer's returned payload
