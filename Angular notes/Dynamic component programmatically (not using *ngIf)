Instead of using *ngIf to conditionally render a component, there's another way.

File 1:
First, in the component that you want to do the actual embedding in,
instantiate a prop of type ComponentFactoryResolver in the ctor.

Then, import the component you want to programmatically render dynamically, and resolve the ComponentFactoryResolver with your desired component.
Store this in a variable, like so:
e.g. - const alertCmpFactory = this.componentFactoryResolver.resolveComponentFactory(AlertComponent);
This just gives us our factory, which is what angular can work with

File 2:
The component we want to embed needs to be a directive, and needs to have a type of ViewContainerRef in its ctor.
This will be a reference to the view/component that we will embed our dynamic component in.

File 1
Back in file 1, add an ng-template block in your html file, and specify the directive name when declaring ng-template.
Declare a prop in the component as a ViewChild, of type YourDirective to to represent the dynamic component, let's call it alertHost (for a dynamic alert component)

In the same place as you call ".resolveComponentFactory()" (see top of this note file), get a reference to your container host (ng-template).
Then, clear it and populate it again with the value in the parenthesis of resolveComponentFactory()

---
To get this to work, you also need to add a new property to app.module named entryComponents: [AlertComponent]
The reason for this is that when the app is initialising, Angular scans your template and routes to see what components it may need later.
It knows this by the component specified in the route, or the selector specified in the template.
(Remember, in your component files, you always specify the alias to represent your component in html templates)
@Component({
  selector: 'app-auth',
  templateUrl: './auth.component.html'
})

Based on the values in your routing module and templates, Angular looks for components in your app.module file's declarations when loading the app.

Because your programatically rendered component isn't in the routing module or explicitly declared in a template, it's not loaded ahead of time by Angular.

In comes the entryComponents property
---

e.g.
File 1
import { PlaceholderDirective } from '../shared/placeholder/placeholder.directive';

@ViewChild(PlaceholderDirective, { static: false }) alertHost: PlaceholderDirective;

const alertCmpFactory = this.componentFactoryResolver.resolveComponentFactory(
      AlertComponent
    );

    const hostViewContainer = this.alertHost.viewContainerRef;
    // destroys anything that may have been embedded earlier in the dynamic component container
    hostViewContainer.clear();

    hostViewContainer.createComponent(alertCmpFactory);

the .html of this will have:
<ng-template appPlaceholder></ng-template>


File 2

import { Directive, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appPlaceholder]'
})
export class PlaceholderDirective {
  // holds info about the view/component that we are about to embed a component in
  constructor(public viewContainerRef: ViewContainerRef) { }
}

