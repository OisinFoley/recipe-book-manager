In the example of using an auth guard class and an interceptor class, we may need to tap into the auth part of the store in order to change the format of the response (interceptor) and to check if a user exists and hence, can they access the guarded route (guard)

With a non-store approach, one idea to access the auth details is to subscribe to a subject which you're managing in a service(e.g. - auth service).

So, for auth guard, you have something like this:

return this.authService.user.pipe(
      take(1),
      map(user => {
        const isAuth = !!user;
        if (isAuth) {
          return true;
        }
        return this.router.createUrlTree(['/auth']);
      })
    );

and for the interceptor, you may have somehting like this:

return this.authService.user.pipe(
      take(1),
      exhaustMap(user => {
        if (!user) {
          return next.handle(req);
        }
        const modifiedRequest = req.clone({
          params: new HttpParams().set('auth', user.token)
        });

        return next.handle(modifiedRequest);
      })
    );

When using a store though, we would be first selecting from our store (instead of subscribing), and in both the guard and interceptor, we would need to call a map function which extracts the user property out of the selected auth store.
This is so that this extracted user can be fed into
1. the guard's other map function (which checks if 'isAuth') and
2. the interceptors exhaustMap function

Just a small difference in use of guards and interceptors (when using stores) to be aware of.

------------------------------

Guard & Interceptors sample code snippets with use of store

guard

return this.store.select('auth').pipe( { // * NOTE THIS LINE *
      take(1),
      map(authState => { // * NOTE THESE 3 LINES *
        return authState.user;
      }),
      map(user => {
        const isAuth = !!user;
        if (isAuth) {
          return true;
        }
        return this.router.createUrlTree(['/auth']);
      })
    );

interceptor

return this.store.select('auth').pipe( // * NOTE THIS LINE  *
      take(1),
      map(authState => { // * NOTE THESE 3 LINES *
        return authState.user;
      }),
      exhaustMap(user => {
        if (!user) {
          return next.handle(req);
        }
        const modifiedRequest = req.clone({
          params: new HttpParams().set('auth', user.token)
        });

        return next.handle(modifiedRequest);
      })
    );
  }
