by default, angular's http class will just provide the extracted body in the response that you subscribe to when making the request.
if you want to get the full body or even the full http response, then in the http methods's third argument, specify "observe: body" or "observe: response".
http.post(url, body, { observe: "body" })...

"responseType" can be used to specify a format for how to handle the response.
default is json.

if you don't provide a body in your http request (the usual second argument), then the headers and queryParams or "observe" property can be specified as the second argument, instead of being the third.
in other words, not sending a body does not mean that you need to send an empty body object whenever you also want to send headers.
just ensure that the property you're sending as the second argument is named "headers", "params"(used to represent queryParams), "responseType", etc..

you have to subscribe to the request that you make, whether post, get or whatever.
otherwise, angular knows that nobody is interested in the request and just doesn't send it at all
therefore, always subscribe

the functions to call http methods are generics, meaning you can specify the type of data you expect in teh response when you call the actual http method
e.g.- http.get<PostModel>(someUrl)

when handling errors in the response, instead of checking for errors directly, you can use an operator built into angular's  http class called "catchError", and that serves as an isolated place for handling errors, like the catch in a try/catch block.
inside "catchError", you can use an rxJs observable named "throwError", meaning that you can just subscribe to this and other interested components can easily act upon the error

setting headers is straightforward;
when you call a http method, the third argument is an object (optional).
inside that object, you specify a headers property, and initialise a new HttpHeaders object.
httpheaders needs to be imported from angular, and inside the parenthesis when initialising
the httpheaders object, you just provide a bunch of key-values pairs and that's your headers added

adding queryParams can be done in 2 ways.
- similar to adding headers, inside the http method's third argument, you also add a property named "params".
you initialise a HttpParams object this time (again, comes from angular http class), but this time you call set() on the initialised object, and provide ('key', 'value') formatted pairs.
- of course, you could skip this way and also just pass them into the url directly when specifying the url ?=someParam=helloThere
- keep in mind that a HttpParams object is immutable, so if you decide to build up your HttpParams object before calling the relevant http method, then you would need to keep reassigning the object like in the following example, whenever you wanted to append to the HttpParams.
e.g. - let searchParams = new HttpParams();
searchParams = searchParams.append('foo', 'bar');
searchParams = searchParams.append('name', 'oisin');
// calling searchParams.append('name', 'oisin'); directly without re-assigning wouldn't work

an aside: tap is an rxJs operator that allows you to "tap-in" to an observables and perform side-actions based on their values, but isn't intended for modifying the observable.
it is similar to rxJs' "map" operator, which is specifically meant for operating/changing an observable before the new value is sent to its subscribers

