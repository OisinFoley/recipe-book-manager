This is split into:
- 1. Setup
- 2. What to expect in browser / search engine
- 3. starting the app from CLI


1. Setup
your component that uses angular universal is going to be rendered on the server.
the component to be rendered will be whatever class you specify inside the 'bootstrap' property inside the app.server.module file that was generated when you ran:
ng add @nguniversal/express-engine --clientProject {â€Œ{ name }}

For our example, it'll be the AppComponent

If a component that's called by the AppComponent tries to use browser apis (like localstorage) when being rendered on the server, then it'll crash.

To get around this, we use a hard-coded global provided by angular called 'PLATFORM_ID' to check if we are in a browser or on a server.

Then, when the AppComponent tries to access a browser api, we can just use a conditional and let it pass depending on the platform being used in that particular instance.

In the following example of using AppComponent, "AutoLogin" will be captured by an auth effect in NgRx, which will try to access localstorage.
Hence, we must prevent "AutoLogin" from being called.

import { Component, OnInit, Inject, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

export class AppComponent implements OnInit {
  constructor(
    private store: Store<fromApp.AppState>,
    @Inject(PLATFORM_ID) private platformId
  ) {}

  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      this.store.dispatch(new AuthAction.AutoLogin());
    }
  }
}

2. What to expect in browser / search engine
When you run the app regularly outside of angular universal, you will see a blank document returned to your route when clicking the "Doc" tab in Chrome DevTools.

Sticking with the above example of the "AppComponent" being the component we wish to render server-side, when we load our app, and look at the "Doc" tab in Chrome DevTools, we will see that the HTML for that page has already been returned to us by the server, meaning the browser will not have to doing any rendering of this very first page.
All other actions and navigation will now take place in the browser.
The benefit is that we have a faster first render.

An aside:
The example we first used Universal in was recipe-book.
When you navigate to the root route, it tries to redirect to /recipes, and if the guard for that route fails, then it'll re-direct to /auth.
Therefore /auth should be the route you see in the "Doc" tab in both Universal and non-Universal mode.

Now, the index page of your site can be properly fetch from search engines (because the server when probed by robots will return the HTML of the index page, whereas when we run the app ourselves, JS is required and robots currently do not universally support SPAs)

If you view the page source (CTRL+U), the returned HTML will now contain the HTML required to render your root route.
Normally, the index.html page is very bare and contains scripts which do the work to load your index page

3. starting the app from CLI
run these commands in terminal window:
	"npm run build:ssr"
	"npm run serve:ssr" 

